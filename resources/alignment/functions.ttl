@prefix cc:      <http://creativecommons.org/ns#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix fno:     <https://w3id.org/function/ontology#> .
@prefix fns:     <https://fno.io/hub/data/resource/> .
@prefix foaf:    <http://xmlns.com/foaf/0.1/> .
@prefix grel:    <http://semweb.mmlab.be/ns/grel#> .
@prefix rdf:     <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:    <http://www.w3.org/2000/01/rdf-schema#> .
@prefix skos:    <http://www.w3.org/2004/02/skos/core#> .
@prefix void:    <http://rdfs.org/ns/void#> .
@prefix xsd:     <http://www.w3.org/2001/XMLSchema#> .

@prefix :        <https://fno.io/hub/data/resource/#> .

fns:void
    a                 void:DatasetDescription ;
    dcterms:title     "A VoID Description of the Function Alignments Dataset of GREL" ;
    dcterms:creator   <https://ben.de-meester.org/#me> ;
    foaf:primaryTopic fns:dataset ;
.

<https://ben.de-meester.org/#me>
    rdf:type  foaf:Person ;
    foaf:mbox "mailto:Ben.DeMeester@UGent.be" ;
    foaf:name "Ben De Meester"@en .

fns:dataset
    a                    void:Dataset ;
    foaf:homepage        <https://fno.io> ;
    dcterms:title        "Function Alignments"@en ;
    dcterms:description  "The alignment of XPath, SPARQL, SQL, SPIN, and GREL functions using the Function Ontology" ;
    dcterms:contributor  <https://ben.de-meester.org/#me> ;
    dcterms:modified     "2018-08-01"^^xsd:date ;
    cc:license           <http://creativecommons.org/license/by/3.0/> ;
    dcterms:issued       "2016-04-30"^^xsd:date ;
    dcterms:rights       "Copyright © Ghent University – imec – IDLab"@en ;
    dcterms:subject      <http://dbpedia.org/resource/Function_(mathematics)> ;
    dcterms:subject      <http://dbpedia.org/resource/Function_model> ;
    void:feature         <http://www.w3.org/ns/formats/Turtle> ;
    void:exampleResource fns:prob_date ;
    void:vocabulary      <http://www.w3.org/2004/02/skos/core#> .

# Contents:
# - Problems (alphabetic) prob_{var}
# - Parameters (alphabetic) param_{var} with predicate {type}_{var}
# -

grel:prob_concat
    a        fno:Problem ;
    fno:name "The concat problem"^^xsd:string ;
    dcterms:description
             "Creating a single string by concatenating all arguments from left to right. Note that if any one of the arguments is unbound (null) then the whole result string will be unbound."^^xsd:string .

grel:fn_concat
    a           fno:Function ;
    fno:solves  :prob_concat ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "Input String 1"^^xsd:string ] [ a             fno:Parameter ;
                                                                   fno:predicate grel:string_s ;
                                                                   rdfs:label    "Input String 2"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate grel:string_s ] .

grel:prob_bool
    a                   fno:Problem ;
    fno:name            "The bool problem"^^xsd:string ;
    dcterms:description ""^^xsd:string .

grel:prob_and
    a                   fno:Problem ;
    fno:name            "The and problem"^^xsd:string ;
    dcterms:description "Returning the logical AND between two (boolean) operands."^^xsd:string .

grel:boolean_and
    a           fno:Function ;
    fno:solves  grel:prob_and ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_input ;
                    rdfs:label    "Input 1"^^xsd:string ] [ a             fno:Parameter ;
                                                            fno:predicate :pred_input ;
                                                            rdfs:label    "Input 2"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_bool ] .

grel:prob_or
    a                   fno:Problem ;
    fno:name            "The or problem"^^xsd:string ;
    dcterms:description "Returning the logical OR between two (boolean) operands."^^xsd:string .

grel:boolean_or
    a           fno:Function ;
    fno:solves  grel:prob_or ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_input ;
                    rdfs:label    "Input 1"^^xsd:string ] [ a             fno:Parameter ;
                                                            fno:predicate :pred_input ;
                                                            rdfs:label    "Input 2"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_bool ] .

grel:prob_not
    a                   fno:Problem ;
    fno:name            "The not problem"^^xsd:string ;
    dcterms:description "Returning the boolean negation of the argument."^^xsd:string .

grel:boolean_not
    a           fno:Function ;
    fno:solves  grel:prob_not ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_input ;
                    rdfs:label    "Input"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_bool ] .

grel:prob_if
    a                   fno:Problem ;
    fno:name            "The if problem"^^xsd:string ;
    dcterms:description "Doing an if-statement."^^xsd:string .

grel:fn_if
    a           fno:Function ;
    fno:solves  :prob_if ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_eval ;
                    rdfs:label    "Evaluation Function"^^xsd:string ] [ a             fno:Parameter ;
                                                                        fno:predicate :pred_true ;
                                                                        rdfs:label    "Value if True"^^xsd:string ] [ a
        fno:Parameter ;
                                                                                                                      fno:predicate
        :pred_false ;
                                                                                                                      rdfs:label
        "Value if False"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_result ] .

grel:prob_string
    a                   fno:Problem ;
    fno:name            "The string problem"^^xsd:string ;
    dcterms:description ""^^xsd:string .

grel:prob_strlen
    a                   fno:Problem ;
    fno:name            "The strlen problem"^^xsd:string ;
    dcterms:description "Computing the length of a given input string."^^xsd:string .

grel:fn_strlen
    a           fno:Function ;
    fno:solves  grel:prob_strlen ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "Input String"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_integer ] .

grel:prob_strstarts
    a                   fno:Problem ;
    fno:name            "The strstarts problem"^^xsd:string ;
    dcterms:description "Whether a string starts another string"^^xsd:string .

grel:fn_strstarts
    a           fno:Function ;
    fno:solves  :prob_strstarts ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "Haystack String"^^xsd:string ] [ a             fno:Parameter ;
                                                                    fno:predicate grel:string_s ;
                                                                    rdfs:label    "Needle String"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_bool ] .

grel:prob_strends
    a                   fno:Problem ;
    fno:name            "The strends problem"^^xsd:string ;
    dcterms:description "Whether a string ends another string"^^xsd:string .

grel:fn_strends
    a           fno:Function ;
    fno:solves  :prob_strends ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "Haystack String"^^xsd:string ] [ a             fno:Parameter ;
                                                                    fno:predicate grel:string_s ;
                                                                    rdfs:label    "Needle String"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_bool ] .

grel:prob_contains
    a                   fno:Problem ;
    fno:name            "The contains problem"^^xsd:string ;
    dcterms:description "Whether a string contains another string"^^xsd:string .

grel:fn_contains
    a           fno:Function ;
    fno:solves  grel:prob_contains ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "Haystack String"^^xsd:string ] [ a             fno:Parameter ;
                                                                    fno:predicate grel:string_s ;
                                                                    rdfs:label    "Needle String"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_bool ] .

grel:prob_lcase
    a                   fno:Problem ;
    fno:name            "The lcase problem"^^xsd:string ;
    dcterms:description "Converting a string to lower case characters."^^xsd:string .

grel:fn_lcase
    a           fno:Function ;
    fno:solves  :prob_lcase ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "Input String"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate grel:string_s ] .

grel:prob_ucase
    a                   fno:Problem ;
    fno:name            "The ucase problem"^^xsd:string ;
    dcterms:description "Converting a string to upper case characters."^^xsd:string .

grel:fn_ucase
    a           fno:Function ;
    fno:solves  grel:prob_ucase ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "Input String"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate grel:string_s ] .

grel:prob_substr
    a                   fno:Problem ;
    fno:name            "The substr problem"^^xsd:string ;
    dcterms:description "Getting the sub-string of a given string"^^xsd:string .

grel:fn_substr
    a           fno:Function ;
    fno:solves  grel:prob_substr ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "Input String"^^xsd:string ] [ a             fno:Parameter ;
                                                                 fno:predicate :pred_integer ;
                                                                 rdfs:label    "Starting Index"^^xsd:string ] [ a
        fno:Parameter ;
                                                                                                                fno:predicate
        :pred_integer ;
                                                                                                                rdfs:label
        "Length"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate grel:string_s ] .

grel:prob_replace
    a        fno:Problem ;
    fno:name "The replace problem"^^xsd:string ;
    dcterms:description
             "Replacing each non-overlapping occurrence of a regular expression pattern with a replacement string. Regular expession matching may involve modifier flags."^^xsd:string .

grel:fn_replace
    a           fno:Function ;
    fno:solves  grel:prob_replace ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "Input String"^^xsd:string ] [ a             fno:Parameter ;
                                                                 fno:predicate grel:string_s ;
                                                                 rdfs:label    "Search String"^^xsd:string ] [ a
        fno:Parameter ;
                                                                                                               fno:predicate
        grel:string_s ;
                                                                                                               rdfs:label
        "Replacement String"^^xsd:string ] [ a             fno:Parameter ;
                                             fno:predicate grel:string_s ;
                                             rdfs:label    "Flags"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate grel:string_s ] .

grel:prob_regex
    a        fno:Problem ;
    fno:name "The regex problem"^^xsd:string ;
    dcterms:description
             "Returning true if a string (?arg1) matches the regular expression supplied as a pattern (?arg2) as influenced by the value of flags (?arg3), otherwise returns false."^^xsd:string .

grel:fn_regex
    a           fno:Function ;
    fno:solves  :prob_regex ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "Input String"^^xsd:string ] [ a             fno:Parameter ;
                                                                 fno:predicate grel:string_s ;
                                                                 rdfs:label    "Regular Expression String"^^xsd:string ]
                  [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "Flags"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_bool ] .

grel:prob_encode_for_uri
    a                   fno:Problem ;
    fno:name            "The encode_for_uri problem"^^xsd:string ;
    dcterms:description "encoding for a URI"^^xsd:string .

grel:fn_encode_for_uri
    a           fno:Function ;
    fno:solves  grel:prob_encode_for_uri ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "Input String"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate grel:string_s ] .

grel:prob_crypto
    a                   fno:Problem ;
    fno:name            "The crypto problem"^^xsd:string ;
    dcterms:description ""^^xsd:string .

grel:prob_md5
    a                   fno:Problem ;
    fno:name            "The md5 problem"^^xsd:string ;
    dcterms:description "Calculating the md5 checksum."^^xsd:string .

grel:fn_md5
    a           fno:Function ;
    fno:solves  :prob_md5 ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "Input String"^^xsd:string ] ) ;
    fno:returns ( grel:output_string ) .

grel:prob_sha1
    a                   fno:Problem ;
    fno:name            "The sha1 problem"^^xsd:string ;
    dcterms:description "Calculating the SHA1 checksum."^^xsd:string .

grel:fn_sha1
    a           fno:Function ;
    fno:solves  :prob_sha1 ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "Input String"^^xsd:string ] ) ;
    fno:returns ( grel:output_string ) .

grel:prob_sha512
    a                   fno:Problem ;
    fno:name            "The sha512 problem"^^xsd:string ;
    dcterms:description "Calculating the SHA512 checksum."^^xsd:string .

grel:fn_sha512
    a           fno:Function ;
    fno:solves  :prob_sha512 ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "Input String"^^xsd:string ] ) ;
    fno:returns ( grel:output_string ) .

grel:prob_sha384
    a                   fno:Problem ;
    fno:name            "The sha384 problem"^^xsd:string ;
    dcterms:description "Calculating the SHA384 checksum."^^xsd:string .

grel:fn_sha384
    a           fno:Function ;
    fno:solves  :prob_sha384 ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "Input String"^^xsd:string ] ) ;
    fno:returns ( grel:output_string ) .

grel:prob_sha256
    a                   fno:Problem ;
    fno:name            "The sha256 problem"^^xsd:string ;
    dcterms:description "Calculating the SHA256 checksum."^^xsd:string .

grel:fn_sha256
    a           fno:Function ;
    fno:solves  :prob_sha256 ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "Input String"^^xsd:string ] ) ;
    fno:returns ( grel:output_string ) .

grel:prob_date
    a                   fno:Problem ;
    fno:name            "The date problem"^^xsd:string ;
    dcterms:description ""^^xsd:string .

grel:prob_timezone
    a                   fno:Problem ;
    fno:name            "The timezone problem"^^xsd:string ;
    dcterms:description "Getting the timezone of a string."^^xsd:string .

grel:fn_timezone
    a           fno:Function ;
    fno:solves  :prob_timezone ;
    fno:expects ( grel:param_string_duration ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_duration ] .

grel:param_string_duration
    a             fno:Parameter ;
    fno:name      "Duration String" ;
    rdfs:label    "Duration String" ;
    fno:predicate grel:string_s ;
    fno:type      xsd:string ;
    fno:required  "true"^^xsd:boolean .

grel:fn_tz
    a           fno:Function ;
    fno:solves  :prob_timezone ;
    fno:expects ( grel:param_string_timezone ) ;
    fno:returns ( grel:output_string ) .

grel:param_string_timezone
    a             fno:Parameter ;
    fno:name      "Timezone String" ;
    rdfs:label    "Timezone String" ;
    fno:predicate grel:string_s ;
    fno:type      xsd:string ;
    fno:required  "true"^^xsd:boolean .

grel:prob_day
    a                   fno:Problem ;
    fno:name            "The day problem"^^xsd:string ;
    dcterms:description "Extracting the day from a date/time literal."^^xsd:string .

grel:fn_day
    a           fno:Function ;
    fno:solves  :prob_day ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_dateTime ;
                    rdfs:label    "DateTime"^^xsd:string ] ) ;
    fno:returns ( grel:output_int ) .

grel:prob_month
    a                   fno:Problem ;
    fno:name            "The month problem"^^xsd:string ;
    dcterms:description "Extracting the month from a date/time literal."^^xsd:string .

grel:fn_month
    a           fno:Function ;
    fno:solves  :prob_month ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_dateTime ;
                    rdfs:label    "DateTime"^^xsd:string ] ) ;
    fno:returns ( grel:output_int ) .

grel:prob_hours
    a                   fno:Problem ;
    fno:name            "The hours problem"^^xsd:string ;
    dcterms:description "Extracting the hours from a date/time literal."^^xsd:string .

grel:fn_hours
    a           fno:Function ;
    fno:solves  :prob_hours ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_dateTime ;
                    rdfs:label    "DateTime"^^xsd:string ] ) ;
    fno:returns ( grel:output_int ) .

grel:prob_seconds
    a                   fno:Problem ;
    fno:name            "The seconds problem"^^xsd:string ;
    dcterms:description "Extracting the seconds from a date/time literal."^^xsd:string .

grel:fn_seconds
    a           fno:Function ;
    fno:solves  :prob_seconds ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_dateTime ;
                    rdfs:label    "DateTime"^^xsd:string ] ) ;
    fno:returns ( grel:output_int ) .

grel:prob_minutes
    a                   fno:Problem ;
    fno:name            "The minutes problem"^^xsd:string ;
    dcterms:description "Extracting the minutes from a date/time literal."^^xsd:string .

grel:fn_minutes
    a           fno:Function ;
    fno:solves  :prob_minutes ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_dateTime ;
                    rdfs:label    "DateTime"^^xsd:string ] ) ;
    fno:returns ( grel:output_int ) .

grel:prob_year
    a                   fno:Problem ;
    fno:name            "The year problem"^^xsd:string ;
    dcterms:description "Extracting the year from a date/time literal."^^xsd:string .

grel:fn_year
    a           fno:Function ;
    fno:solves  :prob_year ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_dateTime ;
                    rdfs:label    "DateTime"^^xsd:string ] ) ;
    fno:returns ( grel:output_int ) .

grel:prob_now
    a                   fno:Problem ;
    fno:name            "The now problem"^^xsd:string ;
    dcterms:description "Getting the current date and time."^^xsd:string .

grel:fn_now
    a           fno:Function ;
    fno:solves  :prob_now ;
    fno:expects ( ) ;
    fno:returns ( grel:output_datetime ) .

grel:prob_mathematical
    a                   fno:Problem ;
    fno:name            "The mathematical problem"^^xsd:string ;
    dcterms:description ""^^xsd:string .

grel:prob_floor
    a        fno:Problem ;
    fno:name "The floor problem"^^xsd:string ;
    dcterms:description
             "Returning the largest (closest to positive infinity) number with no fractional part that is not greater than the given value."^^xsd:string .

grel:fn_floor
    a           fno:Function ;
    fno:solves  :prob_floor ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_number ;
                    rdfs:label    "Input Number"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_result ] .

<https://www.w3.org/TR/sparql11-query/#func-floor>
    skos:broader :fn_floor .

grel:prob_abs
    a                   fno:Problem ;
    fno:name            "The abs problem"^^xsd:string ;
    dcterms:description "Returning the absolute value of the given value."^^xsd:string .

grel:fn_abs
    a           fno:Function ;
    fno:solves  :prob_abs ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_number ;
                    rdfs:label    "Input Number"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_result ] .

<https://www.w3.org/TR/sparql11-query/#func-abs>
    skos:broader :fn_abs .

grel:prob_add
    a                   fno:Problem ;
    fno:name            "The add problem"^^xsd:string ;
    dcterms:description "Returning the sum of the given values."^^xsd:string .

grel:fn_add
    a           fno:Function ;
    fno:solves  :prob_add ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_number ;
                    rdfs:label    "Input Number 1"^^xsd:string ] [ a             fno:Parameter ;
                                                                   fno:predicate :pred_number ;
                                                                   rdfs:label    "Input Number 2"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_number ] .

grel:prob_unaryMinus
    a                   fno:Problem ;
    fno:name            "The unaryMinus problem"^^xsd:string ;
    dcterms:description "Returning the given value with the sign reversed."^^xsd:string .

grel:fn_unaryMinus
    a           fno:Function ;
    fno:solves  :prob_unaryMinus ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_number ;
                    rdfs:label    "Input Number"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_number ] .

grel:prob_sub
    a                   fno:Problem ;
    fno:name            "The sub problem"^^xsd:string ;
    dcterms:description "Returning the arithmetic difference of the given values."^^xsd:string .

grel:fn_sub
    a           fno:Function ;
    fno:solves  :prob_sub ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_number ;
                    rdfs:label    "Input Number 1"^^xsd:string ] [ a             fno:Parameter ;
                                                                   fno:predicate :pred_number ;
                                                                   rdfs:label    "Input Number 2"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_number ] .

grel:prob_mul
    a                   fno:Problem ;
    fno:name            "The mul problem"^^xsd:string ;
    dcterms:description "Returning the arithmetic product of the given values."^^xsd:string .

grel:fn_mul
    a           fno:Function ;
    fno:solves  :prob_mul ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_number ;
                    rdfs:label    "Input Number 1"^^xsd:string ] [ a             fno:Parameter ;
                                                                   fno:predicate :pred_number ;
                                                                   rdfs:label    "Input Number 2"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_number ] .

grel:prob_max
    a                   fno:Problem ;
    fno:name            "The max problem"^^xsd:string ;
    dcterms:description "Returning the largest value of the input."^^xsd:string .

grel:fn_max
    a           fno:Function ;
    fno:solves  :prob_max ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_number ;
                    rdfs:label    "Input Number 1"^^xsd:string ] [ a             fno:Parameter ;
                                                                   fno:predicate :pred_number ;
                                                                   rdfs:label    "Input Number 2"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_number ] .

grel:prob_min
    a                   fno:Problem ;
    fno:name            "The min problem"^^xsd:string ;
    dcterms:description "Returning the smallest value of the input."^^xsd:string .

grel:fn_min
    a           fno:Function ;
    fno:solves  :prob_min ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_number ;
                    rdfs:label    "Input Number"^^xsd:string ] [ a             fno:Parameter ;
                                                                 fno:predicate :pred_number ;
                                                                 rdfs:label    "Input Number"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_number ] .

grel:prob_divide
    a                   fno:Problem ;
    fno:name            "The divide problem"^^xsd:string ;
    dcterms:description "Returning the arithmetic quotient of the given values."^^xsd:string .

grel:fn_divide
    a           fno:Function ;
    fno:solves  :prob_divide ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_number ;
                    rdfs:label    "Input Number 1"^^xsd:string ] [ a             fno:Parameter ;
                                                                   fno:predicate :pred_number ;
                                                                   rdfs:label    "Input Number 2"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_number ] .


grel:prob_rand
    a        fno:Problem ;
    fno:name "The rand problem"^^xsd:string ;
    dcterms:description
             "Returns a number between 0 (inclusive) and 1.0e0 (exclusive). Different numbers can be produced every time this function is invoked. Numbers should be produced with approximately equal probability."^^xsd:string .

grel:fn_rand
    a           fno:Function ;
    fno:solves  :prob_rand ;
    fno:expects ( ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_number ] .

<https://www.w3.org/TR/sparql11-query/#idp2130040>
    skos:broader :fn_rand .

grel:prob_round
    a        fno:Problem ;
    fno:name "The round problem"^^xsd:string ;
    dcterms:description
             "Returning the number with no fractional part that is closest to the argument. If there are two such numbers, then the one that is closest to positive infinity is returned."^^xsd:string .

grel:fn_round
    a           fno:Function ;
    fno:solves  :prob_round ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_number ;
                    rdfs:label    "Input Number"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_number ] .

<https://www.w3.org/TR/sparql11-query/#func-round>
    skos:broader :fn_round .

grel:prob_ceil
    a        fno:Problem ;
    fno:name "The ceil problem"^^xsd:string ;
    dcterms:description
             "Returning the smallest (closest to negative infinity) number with no fractional part that is not less than the value of arg."^^xsd:string .

grel:fn_ceil
    a           fno:Function ;
    fno:solves  :prob_ceil ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_number ;
                    rdfs:label    "Input Number"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_number ] .

grel:prob_composition
    a                   fno:Problem ;
    fno:name            "The composition problem"^^xsd:string ;
    dcterms:description ""^^xsd:string .


grel:prob_misc
    a                   fno:Problem ;
    fno:name            "The misc problem"^^xsd:string ;
    dcterms:description ""^^xsd:string .

grel:prob_eval
    a                   fno:Problem ;
    fno:name            "The eval problem"^^xsd:string ;
    dcterms:description "Evaluating a statement"^^xsd:string .

grel:fn_eval
    a           fno:Function ;
    fno:solves  :prob_eval ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "Statement String"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_result ] .

grel:prob_coalesce
    a                   fno:Problem ;
    fno:name            "The coalesce problem"^^xsd:string ;
    dcterms:description "Returning the first bound argument."^^xsd:string .

grel:fn_coalesce
    a           fno:Function ;
    fno:solves  :prob_coalesce ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_list ;
                    rdfs:label    "Input List"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_result ] .


grel:prob_ontology
    a                   fno:Problem ;
    fno:name            "The ontology problem"^^xsd:string ;
    dcterms:description ""^^xsd:string .

grel:prob_subPropertyOf
    a        fno:Problem ;
    fno:name "The subPropertyOf problem"^^xsd:string ;
    dcterms:description
             "Checking whether a given property is a (transitive) sub-property of another property."^^xsd:string .

grel:fn_subPropertyOf
    a           fno:Function ;
    fno:solves  :prob_subPropertyOf ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_property ;
                    rdfs:label    "Sub-Property"^^xsd:string ] [ a             fno:Parameter ;
                                                                 fno:predicate :pred_property ;
                                                                 rdfs:label    "Parent Property"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_bool ] .

grel:prob_objectCount
    a        fno:Problem ;
    fno:name "The objectCount problem"^^xsd:string ;
    dcterms:description
             "Getting the number of values of a given property (?arg2) at a given subject (?arg1). The result is the number of matches of (?arg1, ?arg2, ?object)."^^xsd:string .

grel:fn_objectCount
    a           fno:Function ;
    fno:solves  :prob_objectCount ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_resource ;
                    rdfs:label    "Subject"^^xsd:string ] [ a             fno:Parameter ;
                                                            fno:predicate :pred_property ;
                                                            rdfs:label    "Predicate"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_integer ] .

grel:prob_subjectCount
    a        fno:Problem ;
    fno:name "The subjectCount problem"^^xsd:string ;
    dcterms:description
             "Getting the number of values of a given property (?arg1) at a given object (?arg2). The result is the number of matches of (?subject, ?arg1, ?arg2)."^^xsd:string .

grel:fn_subjectCount
    a           fno:Function ;
    fno:solves  :prob_subjectCount ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_property ;
                    rdfs:label    "Predicate"^^xsd:string ] [ a             fno:Parameter ;
                                                              fno:predicate :pred_resource ;
                                                              rdfs:label    "Object"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_integer ] .

grel:prob_object
    a        fno:Problem ;
    fno:name "The object problem"^^xsd:string ;
    dcterms:description
             "Getting the object of a given subject (?arg1) / predicate (?arg2) combination. Note that if multiple values are present then the result might be unpredictably random."^^xsd:string .

grel:fn_object
    a           fno:Function ;
    fno:solves  :prob_object ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_resource ;
                    rdfs:label    "Subject"^^xsd:string ] [ a             fno:Parameter ;
                                                            fno:predicate :pred_property ;
                                                            rdfs:label    "Predicate"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_resource ] .

grel:prob_objectInGraph
    a        fno:Problem ;
    fno:name "The objectInGraph problem"^^xsd:string ;
    dcterms:description
             "Gets the object of a given subject (?arg1) / predicate (?arg2) combination in a given graph ?arg3. Note that if multiple values are present then the result might be unpredictably random."^^xsd:string .

grel:fn_objectInGraph
    a           fno:Function ;
    fno:solves  :prob_objectInGraph ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_resource ;
                    rdfs:label    "Subject"^^xsd:string ] [ a             fno:Parameter ;
                                                            fno:predicate :pred_property ;
                                                            rdfs:label    "Predicate"^^xsd:string ] [ a fno:Parameter ;
                                                                                                      fno:predicate
                                                                                                        :pred_graph ;
                                                                                                      rdfs:label
                                                                                                        "Graph"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_resource ] .

grel:prob_objectSubProp
    a        fno:Problem ;
    fno:name "The objectSubProp problem"^^xsd:string ;
    dcterms:description
             "Getting the object of a given subject (?arg1) / predicate (?arg2) combination, also taking the sub-properties of ?arg2 into account. Note that if multiple values are present then the result might be unpredictably random."^^xsd:string .

grel:fn_objectSubProp
    a           fno:Function ;
    fno:solves  :prob_objectSubProp ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_resource ;
                    rdfs:label    "Subject"^^xsd:string ] [ a             fno:Parameter ;
                                                            fno:predicate :pred_property ;
                                                            rdfs:label    "Predicate"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_resource ] .

grel:prob_strdt
    a                   fno:Problem ;
    fno:name            "The strdt problem"^^xsd:string ;
    dcterms:description "Constructing a literal with lexical form and type as specified by the arguments."^^xsd:string .

grel:fn_strdt
    a           fno:Function ;
    fno:solves  :prob_strdt ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "Input String"^^xsd:string ] [ a             fno:Parameter ;
                                                                 fno:predicate :pred_iri ;
                                                                 rdfs:label    "Data Type IRI"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_literal ] .

grel:prob_bnode
    a        fno:Problem ;
    fno:name "The bnode problem"^^xsd:string ;
    dcterms:description
             "Constructing a blank node that is distinct from all blank nodes in the dataset being queried and distinct from all blank nodes created by calls to this constructor for other query solutions. If the no argument form is used, every call results in a distinct blank node. If the form with a simple literal is used, every call results in distinct blank nodes for different simple literals, and the same blank node for calls with the same simple literal within expressions for one solution mapping."^^xsd:string .

grel:fn_bnode
    a           fno:Function ;
    fno:solves  :prob_bnode ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_literal ;
                    rdfs:label    "Literal to Derive Blank Node from"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_resource ] .

grel:prob_IRI
    a                   fno:Problem ;
    fno:name            "The IRI problem"^^xsd:string ;
    dcterms:description "Creating a IRI resource (node) from a given IRI string"^^xsd:string .

grel:fn_IRI
    a           fno:Function ;
    fno:solves  :prob_IRI ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "IRI String"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_resource ] .

grel:prob_datatype
    a        fno:Problem ;
    fno:name "The datatype problem"^^xsd:string ;
    dcterms:description
             "Returning the datatype IRI of argument ?arg1; returns xsd:string if the parameter is a simple literal."^^xsd:string .

grel:fn_datatype
    a           fno:Function ;
    fno:solves  :prob_datatype ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "Input String"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_class ] .

grel:prob_subClassOf
    a        fno:Problem ;
    fno:name "The subClassOf problem"^^xsd:string ;
    dcterms:description
             "Checks whether a given class (?arg1) is a (transitive) sub-class of another class (?arg2)."^^xsd:string .

grel:fn_subClassOf
    a           fno:Function ;
    fno:solves  :prob_subClassOf ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_class ;
                    rdfs:label    "Sub Class"^^xsd:string ] [ a             fno:Parameter ;
                                                              fno:predicate :pred_class ;
                                                              rdfs:label    "Parent Class"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_bool ] .

grel:prob_subject
    a        fno:Problem ;
    fno:name "The subject problem"^^xsd:string ;
    dcterms:description
             "Gets the 'first' subject of a given predicate (?arg1)/object (?arg2) combination. Note that if multiple values are present then the result might be unpredictably random."^^xsd:string .

grel:fn_subject
    a           fno:Function ;
    fno:solves  :prob_subject ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_property ;
                    rdfs:label    "Predicate"^^xsd:string ] [ a             fno:Parameter ;
                                                              fno:predicate :pred_resource ;
                                                              rdfs:label    "Object"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_resource ] .

grel:prob_bool
    a                   fno:Problem ;
    fno:name            "The bool problem"^^xsd:string ;
    dcterms:description ""^^xsd:string .

grel:prob_lt
    a                   fno:Problem ;
    fno:name            "The lt problem"^^xsd:string ;
    dcterms:description "Returning true if ?arg1 < ?arg2."^^xsd:string .

grel:fn_lt
    a           fno:Function ;
    fno:solves  :prob_lt ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_input ;
                    rdfs:label    "Input 1"^^xsd:string ] [ a             fno:Parameter ;
                                                            fno:predicate :pred_input ;
                                                            rdfs:label    "Input 2"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_bool ] .

grel:prob_ne
    a                   fno:Problem ;
    fno:name            "The ne problem"^^xsd:string ;
    dcterms:description "Returning true if ?arg1 != ?arg2."^^xsd:string .

grel:fn_ne
    a           fno:Function ;
    fno:solves  :prob_ne ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_input ;
                    rdfs:label    "Input 1"^^xsd:string ] [ a             fno:Parameter ;
                                                            fno:predicate :pred_input ;
                                                            rdfs:label    "Input 2"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_bool ] .

grel:prob_le
    a                   fno:Problem ;
    fno:name            "The le problem"^^xsd:string ;
    dcterms:description "Returning true if ?arg1 <= ?arg2."^^xsd:string .

grel:fn_le
    a           fno:Function ;
    fno:solves  :prob_le ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_input ;
                    rdfs:label    "Input 1"^^xsd:string ] [ a             fno:Parameter ;
                                                            fno:predicate :pred_input ;
                                                            rdfs:label    "Input 2"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_bool ] .

grel:prob_ge
    a                   fno:Problem ;
    fno:name            "The ge problem"^^xsd:string ;
    dcterms:description "Returning true if ?arg1 >= ?arg2."^^xsd:string .

grel:fn_ge
    a           fno:Function ;
    fno:solves  :prob_ge ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_input ;
                    rdfs:label    "Input 1"^^xsd:string ] [ a             fno:Parameter ;
                                                            fno:predicate :pred_input ;
                                                            rdfs:label    "Input 2"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_bool ] .

grel:prob_isURI
    a                   fno:Problem ;
    fno:name            "The isURI problem"^^xsd:string ;
    dcterms:description "Checking whether a node is a URI."^^xsd:string .

grel:fn_isURI
    a           fno:Function ;
    fno:solves  :prob_isURI ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_input ;
                    rdfs:label    "Input 1"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_bool ] .

grel:prob_eq
    a                   fno:Problem ;
    fno:name            "The eq problem"^^xsd:string ;
    dcterms:description "Returning true if ?arg1 == ?arg2."^^xsd:string .

grel:fn_eq
    a           fno:Function ;
    fno:solves  :prob_eq ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate :pred_input ;
                    rdfs:label    "Input 1"^^xsd:string ] [ a             fno:Parameter ;
                                                            fno:predicate :pred_input ;
                                                            rdfs:label    "Input 2"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate :pred_bool ] .

grel:prob_strafter
    a        fno:Problem ;
    fno:name "The strafter problem"^^xsd:string ;
    dcterms:description
             "Returning a literal of the same kind (simple literal, plain literal same language tag, xsd:string) as the first argument arg1. The lexical form of the result is the substring of the value of arg1 that proceeds in arg1 the first occurrence of the lexical form of arg2; otherwise the lexical form of the result is the empty string. If the lexical form of arg2 is the empty string, the lexical form of the result is the emprty string."^^xsd:string .

grel:fn_strafter
    a           fno:Function ;
    fno:solves  :prob_strafter ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "HayStack String"^^xsd:string ] [ a             fno:Parameter ;
                                                                    fno:predicate grel:string_s ;
                                                                    rdfs:label    "Needle String"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate grel:string_s ] .

grel:prob_strbefore
    a        fno:Problem ;
    fno:name "The strbefore problem"^^xsd:string ;
    dcterms:description
             "Returning a literal of the same kind (simple literal, plain literal same language tag, xsd:string) as the first argument arg1. The lexical form of the result is the substring of the value of arg1 that precedes in arg1 the first occurrence of the lexical form of arg2; otherwise the lexical form of the result is the empty string. If the lexical form of arg2 is the empty string, the lexical form of the result is the emprty string."^^xsd:string .

grel:fn_strbefore
    a           fno:Function ;
    fno:solves  :prob_strbefore ;
    fno:expects ( [ a             fno:Parameter ;
                    fno:predicate grel:string_s ;
                    rdfs:label    "HayStack String"^^xsd:string ] [ a             fno:Parameter ;
                                                                    fno:predicate grel:string_s ;
                                                                    rdfs:label    "Needle String"^^xsd:string ] ) ;
    fno:returns [ a             fno:Output ;
                  fno:predicate grel:string_s ] .

grel:prob_rdf
    a                   fno:Problem ;
    fno:name            "The rdf problem"^^xsd:string ;
    dcterms:description ""^^xsd:string .


grel:pred_string
    fno:type xsd:string .

grel:pred_date
    fno:type xsd:dateTime .

grel:pred_duration
    fno:type xsd:duration .

grel:pred_integer
    fno:type xsd:integer .

grel:pred_list
    fno:type rdf:List .

grel:pred_error
    fno:type fns:Error .

grel:pred_bool
    fno:type xsd:boolean .

grel:pred_property
    fno:type rdf:Property .

grel:pred_resource
    fno:type rdf:Resource .

grel:pred_class
    fno:type rdf:Class .

grel:prob_URI
    skos:broader :prob_IRI .

grel:fn_objectInGraph
    skos:broader :fn_object .

# HERE

<https://www.w3.org/TR/sparql11-query/#func-ceil>
    skos:broader :fn_ceil .

<https://www.w3.org/TR/sparql11-query/#func-strdt>
    skos:broader :fn_strdt .

<https://www.w3.org/TR/sparql11-query/#func-bnode>
    skos:broader :fn_bnode .

<https://www.w3.org/TR/sparql11-query/#func-sha1>
    skos:broader :fn_sha1 .

<https://www.w3.org/TR/sparql11-query/#func-sha512>
    skos:broader :fn_sha512 .

<https://www.w3.org/TR/sparql11-query/#func-sha384>
    skos:broader :fn_sha384 .

<https://www.w3.org/TR/sparql11-query/#func-sha256>
    skos:broader :fn_sha256 .

<https://www.w3.org/TR/sparql11-query/#func-md5>
    skos:broader :fn_md5 .

<https://www.w3.org/TR/sparql11-query/#func-timezone>
    skos:broader :fn_timezone .

<https://www.w3.org/TR/sparql11-query/#func-contains>
    skos:broader :fn_contains .

<https://www.w3.org/TR/sparql11-query/#func-substr>
    skos:broader :fn_substr .

<https://www.w3.org/TR/sparql11-query/#func-strends>
    skos:broader :fn_strends .

<https://www.w3.org/TR/sparql11-query/#func-strstarts>
    skos:broader :fn_strstarts .

<https://www.w3.org/TR/sparql11-query/#func-strafter>
    skos:broader :fn_strafter .

<https://www.w3.org/TR/sparql11-query/#func-strbefore>
    skos:broader :fn_strbefore .

<https://www.w3.org/TR/sparql11-query/#func-strlen>
    skos:broader :fn_strlen .

<https://www.w3.org/TR/sparql11-query/#func-replace>
    skos:broader :fn_replace .

<https://www.w3.org/TR/sparql11-query/#func-regex>
    skos:broader :fn_regex .

<https://www.w3.org/TR/sparql11-query/#func-ucase>
    skos:broader :fn_ucase .

<https://www.w3.org/TR/sparql11-query/#func-lcase>
    skos:broader :fn_lcase .

<https://www.w3.org/TR/sparql11-query/#func-coalesce>
    skos:broader :fn_coalesce .

<https://www.w3.org/TR/sparql11-query/#func-strlen>
    skos:broader <http://www.w3.org/TR/xpath-functions/#func-string-length> .

grel:prob_timezone
    skos:broader :prob_date .

grel:prob_day
    skos:broader :prob_date .

grel:prob_month
    skos:broader :prob_date .

grel:prob_hours
    skos:broader :prob_date .

grel:prob_seconds
    skos:broader :prob_date .

grel:prob_minutes
    skos:broader :prob_date .

grel:prob_year
    skos:broader :prob_date .

grel:prob_now
    skos:broader :prob_date .

grel:prob_sha1
    skos:broader :prob_crypto .

grel:prob_sha512
    skos:broader :prob_crypto .

grel:prob_sha384
    skos:broader :prob_crypto .

grel:prob_sha256
    skos:broader :prob_crypto .

grel:prob_md5
    skos:broader :prob_crypto .

grel:prob_floor
    skos:broader :prob_mathematical .

grel:prob_abs
    skos:broader :prob_mathematical .

grel:prob_add
    skos:broader :prob_mathematical .

grel:prob_unaryMinus
    skos:broader :prob_mathematical .

grel:prob_sub
    skos:broader :prob_mathematical .

grel:prob_mul
    skos:broader :prob_mathematical .

grel:prob_max
    skos:broader :prob_mathematical .

grel:prob_min
    skos:broader :prob_mathematical .

grel:prob_divide
    skos:broader :prob_mathematical .

grel:prob_rand
    skos:broader :prob_mathematical .

grel:prob_round
    skos:broader :prob_mathematical .

grel:prob_ceil
    skos:broader :prob_mathematical .

grel:prob_if
    skos:broader :prob_composition .

grel:prob_eval
    skos:broader :prob_misc .

grel:prob_coalesce
    skos:broader :prob_misc .

grel:prob_subPropertyOf
    skos:broader :prob_ontology .

grel:prob_objectCount
    skos:broader :prob_ontology .

grel:prob_subjectCount
    skos:broader :prob_ontology .

grel:prob_object
    skos:broader :prob_ontology .

grel:prob_objectInGraph
    skos:broader :prob_ontology .

grel:prob_objectSubProp
    skos:broader :prob_ontology .

grel:prob_strdt
    skos:broader :prob_ontology .

grel:prob_bnode
    skos:broader :prob_ontology .

grel:prob_IRI
    skos:broader :prob_ontology .

grel:prob_datatype
    skos:broader :prob_ontology .

grel:prob_subClassOf
    skos:broader :prob_ontology .

grel:prob_subject
    skos:broader :prob_ontology .

grel:prob_lt
    skos:broader :prob_bool .

grel:prob_not
    skos:broader :prob_bool .

grel:prob_ne
    skos:broader :prob_bool .

grel:prob_le
    skos:broader :prob_bool .

grel:prob_ge
    skos:broader :prob_bool .

grel:prob_isURI
    skos:broader :prob_bool .

grel:prob_eq
    skos:broader :prob_bool .

grel:prob_and
    skos:broader :prob_bool .

grel:prob_or
    skos:broader :prob_bool .

grel:prob_encode_for_uri
    skos:broader :prob_string .

grel:prob_contains
    skos:broader :prob_string .

grel:prob_strends
    skos:broader :prob_string .

grel:prob_ucase
    skos:broader :prob_string .

grel:prob_lcase
    skos:broader :prob_string .

grel:prob_strstarts
    skos:broader :prob_string .

grel:prob_substr
    skos:broader :prob_string .

grel:prob_strlen
    skos:broader :prob_string .

grel:prob_strafter
    skos:broader :prob_string .

grel:prob_replace
    skos:broader :prob_string .

grel:prob_strbefore
    skos:broader :prob_string .

grel:prob_concat
    skos:broader :prob_string .

grel:prob_regex
    skos:broader :prob_string .

<https://www.w3.org/TR/sparql11-query/#func-strlen>
    skos:related <http://www.w3.org/TR/xpath-functions/#func-string-length> .

<https://www.w3.org/TR/sparql11-query/#func-substr>
    skos:related <http://www.w3.org/TR/xpath-functions/#func-substring> .

<https://www.w3.org/TR/sparql11-query/#func-ucase>
    skos:related <http://www.w3.org/TR/xpath-functions/#func-upper-case> .

<https://www.w3.org/TR/sparql11-query/#func-lcase>
    skos:related <http://www.w3.org/TR/xpath-functions/#func-lower-case> .

<https://www.w3.org/TR/sparql11-query/#func-strstarts>
    skos:related <http://www.w3.org/TR/xpath-functions/#func-starts-with> .

<https://www.w3.org/TR/sparql11-query/#func-strends>
    skos:related <http://www.w3.org/TR/xpath-functions/#func-ends-with> .

<http://www.w3.org/TR/xpath-functions/#func-string-length>
    fno:solves :prob_strlen .

<http://www.w3.org/TR/xpath-functions/#func-substring>
    fno:solves :prob_substr .

<http://www.w3.org/TR/xpath-functions/#func-upper-case>
    fno:solves :prob_ucase .

<http://www.w3.org/TR/xpath-functions/#func-lower-case>
    fno:solves :prob_lcase .

<http://www.w3.org/TR/xpath-functions/#func-starts-with>
    fno:solves :prob_strstarts .

<http://www.w3.org/TR/xpath-functions/#func-ends-with>
    fno:solves :prob_strends .
